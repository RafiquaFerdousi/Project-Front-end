Variables and Data Types:
Variables are used to store data in JavaScript. There are several types of data types in JavaScript, including string, number, boolean, null, undefined, and object.

var a = 2;
a++
a+=12
a-+1
let b = 1;
const pi =3.14;

console.log (a);
console.log ("begin");

var myName = "John";
var age = 30;
var isMarried = true;
var car = null;
var pet; // undefined
var person = {
  name: "John",
  age: 30,
  isMarried: true
};

Functions:
Functions are reusable blocks of code that perform specific tasks. They can take arguments and return values.

function addNumbers(a, b) {
  return a + b;
}
console.log(addNumbers(5, 7)); // 12

function greet(name) {
  console.log("Hello, " + name + "!");
}
greet("John"); // Hello, John!

Conditional Statements:
Conditional statements are used to execute different blocks of code based on certain conditions.

var age = 30;
if (age < 18) {
  console.log("You are not old enough to vote.");
} else if (age >= 18 && age < 25) {
  console.log("You can vote, but you can't rent a car.");
} else {
  console.log("You can vote and rent a car.");
}

Loops:
Loops are used to repeat a block of code until a certain condition is met.

var i;
for (i = 0; i < 5; i++) {
  console.log(i);
}

var j = 0;
while (j < 5) {
  console.log(j);
  j++;
}


Events:
JavaScript can also be used to handle user events, such as clicks, mouse movements, and keyboard inputs.

document.getElementById("myButton").addEventListener("click", function() {
  alert("Button clicked!");
});

document.addEventListener("keydown", function(event) {
  console.log("Key pressed: " + event.key);
});

Arrays:
Arrays are used to store collections of data, such as lists of numbers, strings, or objects.

var numbers = [1, 2, 3, 4, 5];
var fruits = ["apple", "banana", "orange"];
var people = [
  { name: "John", age: 30 },
  { name: "Jane", age: 25 },
  { name: "Bob", age: 40 }
];
console.log(numbers[2]); // 3
console.log(fruits.length); // 3
console.log(people[1].name); // Jane

Objects:
Objects are used to store collections of related data and functions.

var person = {
  name: "John",
  age: 30,
  address: {
    street: "123 Main St",
    city: "New York",
    state: "NY"
  },
  sayHello: function() {
    console.log("Hello, my name is " + this.name);
  }
};
console.log(person.name); // John
console.log(person.address.city); // New York
person.sayHello(); // Hello, my name is John


Classes:
Classes are used to create objects with specific properties and methods.

class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHello() {
    console.log("Hello, my name is " + this.name);
  }
}
var john = new Person("John", 30);
console.log(john.name); // John
john.sayHello(); // Hello, my name is John

Asynchronous Programming:
Asynchronous programming allows code to continue running while waiting for long-running tasks, such as network requests or file operations, to complete.


console.log("Start");
setTimeout(function() {
  console.log("Middle");
}, 2000);
console.log("End");

In this example, the "Start" and "End" statements are executed immediately, while the "Middle" statement is executed after a 2-second delay.

DOM Manipulation:
JavaScript can be used to manipulate the Document Object Model (DOM), which is a representation of a web page in the browser.

document.getElementById("myButton").addEventListener("click", function() {
  document.getElementById("myDiv").innerHTML = "Button clicked!";
});

In this example, clicking the button with the ID "myButton" changes the text of the div with the ID "myDiv" to "Button clicked!".

Promises:
Promises are used to handle asynchronous operations and provide a way to handle success and error cases.

function fetchData() {
  return new Promise(function(resolve, reject) {
    setTimeout(function() {
      var data = { name: "John", age: 30 };
      if (data) {
        resolve(data);
      } else {
        reject("Data not found");
      }
    }, 2000);
  });
}

fetchData().then(function(data) {
  console.log(data);
}).catch(function(error) {
  console.log(error);
});


In this example, the fetchData function returns a promise that resolves with the data object after a 2-second delay. The then method is called with a callback function that is executed when the promise is resolved, and the catch method is called with a callback function that is executed when the promise is rejected.

Modules:
Modules are used to organize code into reusable and independent units.

// math.js
export function add(a, b) {
  return a + b;
}
export function subtract(a, b) {
  return a - b;
}

// app.js
import { add, subtract } from './math.js';
console.log(add(5, 7)); // 12
console.log(subtract(10, 3)); // 7



In this example, the math.js module exports two functions add and subtract using the export keyword, and the app.js module imports these functions using the import keyword.

Spread and Rest Operators:
The spread operator (...) and rest operator (...) are used to manipulate arrays and objects.

// spread operator
var numbers1 = [1, 2, 3];
var numbers2 = [4, 5, 6];
var combinedNumbers = [...numbers1, ...numbers2];
console.log(combinedNumbers); // [1, 2, 3, 4, 5, 6]

// rest operator
function sum(...numbers) {
  return numbers.reduce(function(total, num) {
    return total + num;
  }, 0);
}
console.log(sum(1, 2, 3)); // 6
console.log(sum(4, 5, 6, 7)); // 22


Template Literals:
Template literals are used to create strings with placeholders for variables.

var name = "John";
var age = 30;
var message = `My name is ${name} and I am ${age} years old.`;
console.log(message); // My name is John and I am 30 years old.


Regular Expressions:
Regular expressions are used to match and manipulate patterns in strings.

var str = "The quick brown fox jumps over the lazy dog";
var pattern = /fox/;
console.log(pattern.test(str)); // true
console.log(str.replace(/the/gi, "a")); // A quick brown fox jumps over a lazy dog



